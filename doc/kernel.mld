{0 Tapak Kernel}

{1 Introduction}

The {!module:Tapak_kernel} module provides the core request-response processing infrastructure for Tapak. Inspired by {{:https://twitter.github.io/finagle/} Twitter's Finagle}, it implements a composable architecture based on services and filters (middlewares).

{1 Architecture}

Tapak Kernel is built around several key abstractions:

{2 Request and Response}

The {!module:Tapak_kernel.Request} and {!module:Tapak_kernel.Response} modules provide thin wrappers around Piaf's HTTP types, extended with a context system for passing data through the request pipeline.

{[
open Tapak_kernel

let request =
  Request.create
    ~scheme:`HTTP
    ~version:Piaf.Versions.HTTP.HTTP_1_1
    ~meth:`GET
    "/hello"

let response =
  Response.create
    ~body:(Piaf.Body.of_string "Hello!")
    `OK
]}

{2 Context}

The {!module:Tapak_kernel.Context} module provides a type-safe heterogeneous map for storing request-scoped data. This is similar to Finagle's Context or Ring's request map.

{[
(* Define a key *)
let user_key : User.t Context.key =
  Context.Key.create
    { name = Some "user"
    ; show = Some (fun u -> u.User.username)
    }

(* Store and retrieve data *)
let request = Request.create ~meth:`GET "/" in
let request' = Request.with_context
  (Context.add user_key current_user (Request.context request))
  request
in
match Context.find user_key (Request.context request') with
| Some user -> (* ... *)
| None -> (* ... *)
]}

{2 Handlers}

A handler is a function that processes a request and returns a response:

{[
type Handler.t = Request.t -> Response.t
]}

Handlers are the basic building blocks of your application. They represent the actual business logic that processes requests.

{[
let hello_handler request =
  Response.create
    ~body:(Piaf.Body.of_string "Hello, World!")
    `OK
]}

{2 Middleware (Filters)}

The {!module:Tapak_kernel.Middleware} module implements the filter pattern from Finagle. A middleware wraps a handler to add cross-cutting functionality.

Tapak supports two ways to create middleware:

{3 Function-based Middleware (Recommended for Simple Cases)}

For simple middleware, create it directly from a filter function:

{[
(* A filter is: Handler.t -> Handler.t *)
let logger_filter next request =
  let path = Request.target request in
  Printf.printf "REQUEST: %s\n" path;
  next request

let logger_middleware = Middleware.create ~filter:logger_filter ~name:"logger"
]}

{3 Module-based Middleware (For Configuration or State)}

For middleware that needs configuration or state, use the module interface:

{[
module type Intf = sig
  type t

  val call : t -> (Request.t, Response.t) Filter.simple
end
]}

Example:

{[
module Logger = struct
  type t = { prefix : string }

  let call { prefix } next request =
    let path = Request.target request in
    Printf.printf "%s: %s\n" prefix path;
    next request
end

let logger = Middleware.use ~name:"logger" (module Logger) { prefix = "REQUEST" }
]}

Middlewares can:
- Add request/response logging
- Implement authentication and authorization
- Handle errors and exceptions
- Add caching
- Compress responses
- And much more...

{2 Apps}

The {!module:Tapak_kernel.App} module combines handlers with middlewares to create complete applications:

{[
let app =
  App.create
    ~middlewares:[logger; auth_middleware]
    ~handler:my_handler
    ()

(* Execute the app *)
let response = App.call app request
]}

{2 Router}

The {!module:Tapak_kernel.Router} module provides GADT-based type-safe routing with:

- Typed path parameters: [int64], [str], [bool], etc.
- Splat matching: capture remaining path segments as [string list]
- Scoped routes with middleware isolation
- RESTful resource routing
- Type-safe URL generation via [sprintf]

{[
open Router

let routes =
  App.routes
    [ scope (s "api")
        [ get (s "users") @-> list_users
        ; get (s "users" / int64) @-> get_user
        ; post (s "users") @-> create_user
        ]
    ; scope (s "admin")
        [ get (s "spa" / splat) @-> serve_admin_spa ]
    ]
    ()
]}

See {!page-router} for detailed routing documentation.

{1 Modules}

The kernel package exports the following modules:

- {!module:Tapak_kernel.Context} - Type-safe heterogeneous maps
- {!module:Tapak_kernel.Request} - HTTP request handling
- {!module:Tapak_kernel.Response} - HTTP response creation
- {!module:Tapak_kernel.Handler} - Request handler abstraction
- {!module:Tapak_kernel.Middleware} - Middleware/filter system
- {!module:Tapak_kernel.App} - Application composition
- {!module:Tapak_kernel.Router} - Pattern-based routing

{1 Design Philosophy}

{2 Composability}

Every component in Tapak is designed to be composable. Small, focused functions and modules can be combined to build complex functionality.

{2 Type Safety}

Tapak leverages OCaml's type system to catch errors at compile time. The Context module provides type-safe storage, and the middleware system ensures proper composition.

{2 Simplicity}

While powerful, Tapak strives to remain simple. The core abstractions are easy to understand and use, while still providing the flexibility needed for complex applications.

{2 Performance}

Built on EIO (OCaml 5's effect-based I/O), Tapak delivers excellent performance without sacrificing safety or composability.

{1 Comparison to Finagle}

For those familiar with Finagle, here's how Tapak's concepts map:

- [Service[Req, Rep\]] → [Handler.t] (specialized to HTTP)
- [Filter] → {!module:Tapak_kernel.Middleware}
- [Context] → {!module:Tapak_kernel.Context}
- [Stack] → {!module:Tapak_kernel.App}

{1 Examples}

{2 Complete Application}

{[
open Tapak_kernel

let logger_filter next request =
  Logs.info (fun m -> m "Request: %s" (Request.target request));
  next request

let logger = Middleware.create ~filter:logger_filter ~name:"logger"

let home_handler _request =
  Response.of_html ~status:`OK "<h1>Home</h1>"

let user_handler (user_id : int64) _request =
  (* user_id is automatically parsed and typed as int64 *)
  let body = Printf.sprintf "<h1>User %Ld</h1>" user_id in
  Response.of_html ~status:`OK body

let app =
  let open Router in
  App.routes
    [ scope
        ~middlewares:[logger]
        (s "")
        [ get (s "") @-> home_handler
        ; get (s "users" / int64) @-> user_handler
        ]
    ]
    ()
]}

{1 Next Steps}

- Read the {!page-router} guide for detailed routing documentation
- Learn about {!page-middleware} to add cross-cutting concerns
- See module documentation: {!module:Tapak_kernel}
